#GameConnectの使い方について
みなさんこんにちは、このライブラリ(ライブラリと言うほどのものでもありませんが..)の製作者であるJin(Twitter: @CPP_IS_GOD)です。
ここではGameConnectの使い方を説明したいと思います。
##開発の背景
みなさんは何かしらゲームを作りたいときはどのような言語を使うでしょうか？
無難にC++とゲームライブラリ(DXライブラリ、Siv3Dなど)で開発する人が多いと思います(もちろんそうでない方もいると思いますが)。
そしてゲームに通信対戦などのような機能を実装したいとき、C++で実装するとかなり大変です(し、ゲームの本質に関わらないコードが増えて可読性も下がってしまいます)。
「自由度は高くなくていいから、とにかく簡単に短く通信対戦を実装したい！」という人に向けて、今回「GameConnect」というライブラリを作ってみました(本当にライブラリと言えるほどのものではありませんが...)。
##使い方
使い方は簡単です。
ヘッダオンリなので`#include "gameconnect.hpp"`をして、最初に`Jin::GameConnect`のインスタンスを生成します(その際にソケットを開くポート番号も指定。デフォルトだと3000。同じマシンで2つのプログラムを走らせる場合、必ずポート番号が被らないようにしてください)。ちなみに、ソケット通信はゲームスレッドは別に並行処理をしているので何の支障も出ません。そして好きな時(ゲームループの中などで)にSend関数で情報を送ってGet関数で送られてきた情報を取得します(情報が送られてきたらキューに追加するようにしています。詳しくはソースコードをご覧ください)。少しここで注意なのですが、情報の送信にはバイト列(char型の配列)が適しているので、送るときはchar型の配列に変換して、取得するときは各自の型(int型の変数を送信するのなら、int型に変換してあげる)に変換してあげる必要があります(Jin::Dataがchar[256]としてヘッダファイルでは定義されています)。
例(自機の座標を通信させたいとき):
送信側のコード
~~~cpp
#include "gameconnect.hpp"

struct pos{
  int x, y;
};

int main(){

  Jin::GameConnect g(4000);//ポート4000でソケットを開く

  pos p = { 12, 12 };
  Jin::Data data;
  *(pos*)data = p;//通信用のデータに変換
  g.Send(Jin::getIP()/*情報を送りたいマシンのIPアドレスを指定。このプログラムが走っているマシンのIPアドレスはgetIP関数で取得できます*/, 3000/*送信先のポート番号*/, data);

  return 0;
}
~~~
受信側のコード
~~~cpp
#include <iostream>
#include "gameconnect.hpp"

struct pos{
  int x, y;
};

int main() {

  Jin::GameConnect connection(3000);
  pos p;

  p = *(pos*)connection.Get();//通信用のデータから実際の型に変換します

  std::cout << p.x << " " << p.y << std::endl;//"12 12"と出力されます

  return 0;
}
~~~

##最後に
まだまだ僕は未熟なので、何か質問・文句・提案などがあればこのレポジトリにissue投げるなり、Twitterで僕に話しかけるなりしてください。いつでもお待ちしております。
(時間に余裕ができたらOpenSiv3DとGameConnectを組み合わせたサンプルゲームを作ろうと思います)