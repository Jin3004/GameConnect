# GameConnectの使い方について
みなさんこんにちは、このライブラリ(ライブラリと言うほどのものでもありませんが..)の製作者であるJin(Twitter: @univ_jin)です。
ここではGameConnectの使い方を説明したいと思います。

## 開発の背景
みなさんは何かしらゲームを作りたいときはどのような言語を使うでしょうか？  無難にC++とゲームライブラリ(DXライブラリ、Siv3Dなど)で開発する人が多いと思います(もちろんそうでない方もいると思いますが)。  そしてゲームに通信対戦などのような機能を実装したいとき、C++で実装するとかなり大変です(し、ゲームの本質に関わらないコードが増えて可読性も下がってしまいます)。  「自由度は高くなくていいから、とにかく簡単に短く通信対戦を実装したい！」という人に向けて、今回「GameConnect」というライブラリを作ってみました(本当にライブラリと言えるほどのものではありませんが...)。

## 使い方
使い方は簡単です。  このレポジトリから`include`フォルダを落としてきて追加のインクルードディレクトリ等に追加します。そして使いたいソースコードの最初に`#include "gameconnect.hpp"`を書いて、最初に`Jin::GameConnect`のインスタンスを生成します(その際にソケットを開くポート番号も指定。デフォルトだと3000。同じマシンで2つのプログラムを走らせる場合、必ずポート番号が被らないようにしてください)。  ちなみに、ソケット通信はゲームスレッドは別に並行処理をしているので何の支障も出ません。そして好きな時(ゲームループの中などで)にSend関数で情報を送ってGet関数で送られてきた情報を取得します(情報が送られてきたらキューに追加するようにしています。詳しくはソースコードをご覧ください)。  
例(自機の座標を通信させたいとき):
送信側のコード
~~~cpp
#include "gameconnect.hpp"

struct pos{
  int x, y;
};

int main(){

  Jin::GameConnect g(4000);//ポート4000でソケットを開く

  pos p = { 12, 12 };
  g.Send(Jin::getIP()/*情報を送りたいマシンのIPアドレスを指定。このプログラムが走っているマシンのIPアドレスはgetIP関数で取得できます*/, 3000/*送信先のポート番号*/, p/*送りたいデータ*/);

  return 0;
}
~~~
受信側のコード
~~~cpp
#include <iostream>
#include "gameconnect.hpp"

struct pos{
  int x, y;
};

int main() {

  Jin::GameConnect connection{ 3000 };//ポート3000でソケットを開く
  pos p = connection.Get<pos>();//データが送られてきたらキューに溜められるのでそこからデータを取得

  std::cout << p.x << " " << p.y << std::endl;//"12 12"と出力されます

  return 0;
}
~~~

## 最後に
まだまだ僕は未熟なので、何か質問・文句・提案などがあればこのレポジトリにissue投げるなり、Twitterで僕に話しかけるなりしてください。いつでもお待ちしております。
(時間に余裕ができたらOpenSiv3DとGameConnectを組み合わせたサンプルゲームを作ろうと思います)
